{"name":"Distance-heat-maps","tagline":"Interesting things you can do with a distance-type function","body":"### Drawing with Distance\r\nHow do you teach a computer to draw on it's own? One of the easiest ways to do this is to teach the computer some metric of distance and then to colour the pixels on the page based on the distance of each pixel to a particular point. Below I'm going to introduce the basics using your bog standard [linear distance between points](http://mathworld.wolfram.com/Distance.html). If you want to use the same program to represent some complicated data or simply to draw more subtle images then you may want to investigate what happens if you use other metrics of distance i.e. if you alter what you _mean_ by distance.\r\n\r\nThe simplest case is to take a single point at the centre of your page (0,0) and calculate every pixel's distance to that point, colouring in the page based on the distance. Doing this might give you an image that looks something like this\r\n\r\n![distance to point](https://cloud.githubusercontent.com/assets/7373621/8260097/5d88651c-16b9-11e5-94d4-c197f7fab784.jpg)\r\n\r\nChanging the colour map used to fill in the pixels and additionally take the _sin()_ of the distance as the colour indicator you might get an image which looks something like\r\n\r\n![distance to point with sin](https://cloud.githubusercontent.com/assets/7373621/8260098/5d886544-16b9-11e5-8faa-46ee91c2eb2e.jpg)\r\n\r\n### Lines or Curves\r\nSuppose that instead of a point you calculate the minimum [perpendicular distance of each point to a line](http://mathworld.wolfram.com/Point-LineDistance2-Dimensional.html). This can be done using the same function [get_min_perp.m](https://github.com/rupertsmall/distance-heat-maps/blob/master/get_min_perp.m) as the first example above. If your line is a _sin()_ curve, say, then you might generate an image which looks something like this\r\n\r\n![distance to sin( ) curve](https://cloud.githubusercontent.com/assets/7373621/8260102/5d8ae7ce-16b9-11e5-9b94-08179a7aa8c0.jpg)\r\n\r\nAs before if you change the colour map used to fill in the colour of each pixels and take the _lognormal_ of the distance instead (or any other function for that matter) you might get something like\r\n\r\n![distance to sin( ) with lognormal](https://cloud.githubusercontent.com/assets/7373621/8260100/5d8ace6a-16b9-11e5-8322-7423a67817aa.jpg)\r\n\r\n### Random Drawing\r\nWhat happens if your curve is random? Now the [get_min_perp.m](https://github.com/rupertsmall/distance-heat-maps/blob/master/get_min_perp.m) function behaves exactly as before, except that its now calculating the perpendicular distance to a randomly generated curve. Drawing the result _will not_ look like this for you, because the result will change every time you run the program (it's random after all!). The output on my computer looked like this\r\n\r\n![distance to random curve](https://cloud.githubusercontent.com/assets/7373621/8260099/5d8ab0a6-16b9-11e5-8ed1-c8708b4962af.jpg)\r\n\r\nand changing the colour map and taking the _lognormal_ of the distance gave me this\r\n\r\n![distance to random with lognormal](https://cloud.githubusercontent.com/assets/7373621/8260101/5d8b6154-16b9-11e5-93aa-862cdf911895.jpg)\r\n\r\n```\r\nfigure\r\nh=pcolor(X,Y,sin(2*dist));\r\nset(h,'EdgeColor','none')\r\nset(gcf,'Renderer','Zbuffer')\r\ncolormap(winter)\r\ncolorbar\r\nhold on\r\n\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}