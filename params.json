{"name":"Distance-heat-maps","tagline":"Interesting things you can do with a distance-type function","body":"### Drawing with Distance\r\nHow do you teach a computer to draw on it's own? One of the easiest ways to do this is to teach the computer some metric of distance and then to colour the pixels on the page based on the distance of each pixel to a particular point. Below I'm going to introduce the basics using your bog standard [linear distance between points](http://mathworld.wolfram.com/Distance.html). If you want to use the same program to represent some complicated data or simply to draw more subtle images then you may want to investigate what happens if you use other metrics of distance i.e. if you alter what you _mean_ by distance.\r\n\r\nThe simplest case is to take a single point at the centre of your page (0,0) and calculate every pixel's distance to that point, colouring in the page based on the distance. Doing this might give you an image that looks something like this\r\n\r\n![distance to point](https://cloud.githubusercontent.com/assets/7373621/8260097/5d88651c-16b9-11e5-94d4-c197f7fab784.jpg)\r\n\r\nChanging the colour map used to fill in the pixels and additionally take the _sin()_ of the distance as the colour indicator you might get an image which looks something like\r\n\r\n![distance to point with sin](https://cloud.githubusercontent.com/assets/7373621/8260098/5d886544-16b9-11e5-8faa-46ee91c2eb2e.jpg)\r\n\r\n### Lines or Curves\r\nSuppose that instead of a point you calculate the minimum [perpendicular distance of each point to a line](http://mathworld.wolfram.com/Point-LineDistance2-Dimensional.html). This can be done using the same function [get_min_perp.m](https://github.com/rupertsmall/distance-heat-maps/blob/master/get_min_perp.m) used to draw the first examples above. If your line is a _sin()_ curve, say, then you might generate an image which looks something like this\r\n\r\n![distance to sin( ) curve](https://cloud.githubusercontent.com/assets/7373621/8260102/5d8ae7ce-16b9-11e5-9b94-08179a7aa8c0.jpg)\r\n\r\nAs before if you change the colour map used to fill in the colour of each pixels and take the _lognormal_ of the distance instead (or any other [function](http://mathworld.wolfram.com/Function.html) for that matter) you might get something like\r\n\r\n![distance to sin( ) with lognormal](https://cloud.githubusercontent.com/assets/7373621/8260100/5d8ace6a-16b9-11e5-8322-7423a67817aa.jpg)\r\n\r\n### Random Drawing\r\nWhat happens if your curve is random? Now the [get_min_perp.m](https://github.com/rupertsmall/distance-heat-maps/blob/master/get_min_perp.m) function behaves exactly as before, except that its now calculating the perpendicular distance to a randomly generated curve. Drawing the result _will not_ look like this for you, because the result will change every time you run the program (it's random after all!). The output on my computer looked like this\r\n\r\n![distance to random curve](https://cloud.githubusercontent.com/assets/7373621/8260099/5d8ab0a6-16b9-11e5-8ed1-c8708b4962af.jpg)\r\n\r\nand changing the colour map and taking the _lognormal_ of the distance gave me this\r\n\r\n![distance to random with lognormal](https://cloud.githubusercontent.com/assets/7373621/8260101/5d8b6154-16b9-11e5-93aa-862cdf911895.jpg)\r\n\r\nThe above introduces the basics. What if you want to draw more nuanced images? Without changing [get_min_perp.m](https://github.com/rupertsmall/distance-heat-maps/blob/master/get_min_perp.m) you can\r\n\r\n* Define more complex lines/curves from which the distance is calculated\r\n* Take more complex functions of the distance\r\n* Define your own colour maps\r\n\r\n### Code\r\nAll the code for the examples above are [Maltab](http://www.matlab.com)/[Octave](http://www.gnu.org/software/octave/)\r\n\r\n### Drawing with Distance Code\r\nDistance from a single point (0,0)\r\n```\r\nN = 1000;\r\nx = 0;\r\ny = 0;\r\n \r\nlower_x = min(x) -5; upper_x = max(x) +5; % for sensible window size\r\nlower_y = min(y) -5; upper_y = max(y) +5;\r\n[X Y] = meshgrid(linspace(lower_x, upper_x, N),linspace(lower_y, upper_y, N));\r\n% get minimum perpendicular distance\r\ndist = get_min_perp(x,y,X,Y,N);\r\n \r\n% plot results from get_min_perp for (0,0)\r\nfigure\r\nh=pcolor(X,Y,dist);\r\nset(h,'EdgeColor','none')\r\nset(gcf,'Renderer','Zbuffer')\r\ncolormap(hot)\r\ncolorbar\r\n```\r\nTaking _sin()_ of the distance and changing the colour pallet\r\n```\r\nfigure\r\nh=pcolor(X,Y,sin(2*dist));\r\nset(h,'EdgeColor','none')\r\nset(gcf,'Renderer','Zbuffer')\r\ncolormap(winter)\r\ncolorbar\r\n```\r\n### Lines and Curves Code\r\nDistance to _sin()_ curve\r\n```\r\nx = linspace(0,5*pi,50);\r\ny = sin(x);\r\n \r\nlower_x = min(x); upper_x = max(x);\r\nlower_y = min(y); upper_y = max(y);\r\n[X Y] = meshgrid(linspace(lower_x, upper_x, N),linspace(lower_y, upper_y, N));\r\ndist = get_min_perp(x,y,X,Y,N);\r\n \r\nfigure\r\nh=pcolor(X,Y,dist);\r\nset(h,'EdgeColor','none')\r\nset(gcf,'Renderer','Zbuffer')\r\ncolormap(hot)\r\ncolorbar\r\n```\r\n\r\n_lognormal_(_5_ x distance) to the _sin()_ curve with altered colourmap\r\n```\r\nfigure\r\nh=pcolor(X,Y,lognormal(5*dist));\r\nset(h,'EdgeColor','none')\r\nset(gcf,'Renderer','Zbuffer')\r\ncolormap(winter)\r\ncolorbar\r\n```\r\n### Random Drawing Code\r\nDrawing using distance to randomly generated curve\r\n```\r\nx = rand(1,10);\r\ny = rand(1,10);\r\n \r\nlower_x = min(x); upper_x = max(x);\r\nlower_y = min(y); upper_y = max(y);\r\n[X Y] = meshgrid(linspace(lower_x, upper_x, N),linspace(lower_y, upper_y, N));\r\ndist = get_min_perp(x,y,X,Y,N);\r\n \r\nfigure\r\nh=pcolor(X,Y,dist);\r\nset(h,'EdgeColor','none')\r\nset(gcf,'Renderer','Zbuffer')\r\ncolormap(hot)\r\ncolorbar\r\n```\r\nChanging the colour pallet and taking the _lognormal_ of distance\r\n```\r\nfigure\r\nh=pcolor(X,Y,lognormal(dist+1));\r\nset(h,'EdgeColor','none')\r\nset(gcf,'Renderer','Zbuffer')\r\ncolormap(winter)\r\ncolorbar\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}